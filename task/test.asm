.model small
.stack 64
.data
		Matrix  dw 1, 3, 6, 100, 200, 300, 6, 28, 496, 5, 25, 125
		Columns db 3
		Rows    db 4
.code
Main proc far
		mov ax, @data
		mov ds, ax

		xor dh, dh      ; կատարյալ տողերի քանակը կպահենք dh-ում
		xor bx, bx      ; հաշվարկը կսկսենք 0-ից
		mov al, Columns ; ax-ում կպահենք սյուների քանակը արագ հասանելիության համար
		xor ah, ah
		mov cl, Rows    ; cx-ում տողերի քանակով պետք է կրկնենք տվյալ գործողությունը
		xor ch, ch
	MtrxLoop:
		push cx       ; պահում ենք cx-ի արժեքը, քանի որ նրանով ենք աշխատելու
		mov  cx, ax   ; ֆունկցիան պետք է անցնի սյուների քանակին հավասար քանակությամբ անդամների վրայով
		call IsPfcRow ; ստուգում ենք տողի կատարյալ լինելը
		cmp  dl, 1
		jne  NextIte2 ; չլինելու դեպքում անցնում ենք NextIte2
		inc  dh       ; լինելու դեպքում ավելացնում ենք 1-ով նոր ենք անցնում
	NextIte2:
		pop  cx       ; վերականգնում ենք cx-ը
		add  bx, ax   ; bx-ը պետք է ավելացվի սյուների քանակ * բայթերի քանակով, որը տվյալ դեպքում 2 է
		add  bx, ax   ; հետևաբար ես ուղղակի 2 անգամ կավելացնեմ bx-ին սյուների քանակը
		loop MtrxLoop ; կրկնում ենք ցիկլը
		mov  al, dh
		xor  ah, ah
		call PrNumber

		ret
Main    endp

; Ստուգում է ax ռեգիստորը բաժանվում է bx-ի վրա անմնացորդ
; Արդյունքը վերադարձնում է 0 / 1 տեսքով dl-ում
IsDivis proc
		push ax       ; պահում ենք փոփոխվող ռեգիստորները
		push dx       ; պահում ենք dx-ը շուտով վերականգնելու համար
		xor  dx, dx   ; զրոյացնում ենք dx-ը բաժանելու համար
		div  bx       ; բաժանում ենք ax-ը bx-ի վրա ստանալով dx մնացորդ
		cmp  dx, 0    ; համեմատում ենք մնացորդը 0-ի հետ
		je   True1    ; եթե հավասար է անցնում է True1 նշիչին
		pop  dx       ; հակառակ դեպքում վերականգնում ենք dx-ը (dh-ը վերականգնելու համար)
		xor  dl, dl   ; dl-ը զրոյացնում ենք (այսինքն false արժեք)
		jmp  ProcEnd1 ; անցնում ենք ProcEnd1 նշիչին
	True1:
		pop dx    ; ճիշտ արդյունքի դեպքում վերականգնում ենք dx-ը (dh-ը վերականգնելու համար)
		mov dl, 1 ; dl-ին վերագրում ենք 1 (այսինքն true արժեք)
	ProcEnd1:
		pop ax ; վերականգնում ենք ax-ը
		ret 
IsDivis  endp

; ստուգում է ax ռեգիստորը կատարյալ է
; արդյունքը վերադարձնում է 0 / 1 տեսքով dl-ում
IsPerfec proc
		push si bx cx dx ; պահում ենք փոփոխվող ռեգիստորները
		push ax          ; պահում ենք ax-ը շուտով վերականգնելու համար
		xor  si, si      ; զրոյացնում ենք գումարը (բաժանարարների գումարը կպահենք si-ում, ուրիշ ռեգիստոր չկա ¯\_(ツ)_/¯)
		mov  bx, 2       ; պատրաստվում ենք բաժանել 2-ի
		xor  dx, dx      ; ավելի ուժեղ ենք պատրաստվում բաժանել 2-ի
		div  bx          ; բաժանում ենք 2-ի
		mov  cx, ax      ; արդյունքը տեղափոխում ենք cx (որպես հաշվիչ և հերթական բաժանարար)
		pop  ax          ; վերականգնում ենք ax-ը
	DivCheck: 
		cmp  cx, 1    ; եթե հերթական բաժանարարը փոքր է մեկից․․․
		jl   LoopEnd1 ; ավարտում ենք ցիկլը
		mov  bx, cx   ; հակառակ դեպքում տեղափոխում ենք bx բաժանման համար
		call IsDivis  ; ստուգում ենք բաժանելիությունը
		cmp  dl, 1
		jne  NextIte1 ; եթե չի բաժանվում անցնում ենք NextIte1 նշիչին
		add  si, bx   ; բաժանվելու դեպքում գումարում ենք si-ին
	NextIte1:
		dec cx       ; անցնում ենք մեկով փոքր բաժանարարին
		jmp DivCheck ; կրկնում ենք ցիկլը
	LoopEnd1:
		pop dx       ; վերականգնում ենք dx-ը (dh-ը վերականգնելու համար)
		xor dl, dl   ; զրոյացնում ենք dl-ը (եթե false արդյունք ստացվի կթողնենք այդպես)
		cmp ax, si   ; համեմատում ենք նախնական թիվն ու գումարը
		jne ProcEnd2 ; եթե հավասար չեն անցնում ենք վերջին (false) արդյունքով
		mov dl, 1    ; եթե հավասար են անցնում ենք վերջին (true) արդյունքով
	ProcEnd2:
		pop cx bx si ; վերականգնում ենք փոփոխված ռեգիստորները
		ret
IsPerfec endp

; ստուգում է Matrix-ում տարրերի կատարյալ լինելը bx հասցեից սկսած cx-ի չափով
; արդյունքը վերադարձնում է 0 / 1 տեսքով dl-ում
IsPfcRow proc
		push di ax cx ; պահում ենք փոփոխվող ռեգիստորները
		xor  di, di   ; զրոյացնում ենք հասցեն
	RowCheck:
		mov  ax, Matrix[bx][di] ; ax-ում պահում ենք տողի հերթական տարրը
		call IsPerfec           ; ստուգում ենք կատարյալ լինելը
		cmp  dl, 1
		jne  False2             ; եթե կատարյալ չէ անցնում է False2 նշիչին
		add  di, 2              ; հակառակ դեպքում հասցեն ավելացնում է 1-ով
		loop RowCheck           ; և կրկնում ստուգումը հաջորդ տարրի համար
		mov  dl, 1              ; ցիկլը ավարտելուց և false չստանալու դեպքում վերագրում ենք dl-ին 1 (true)
		jmp  ProcEnd3           ; անցնում ենք վերջին
	False2:
		xor dl, dl ; սխալ արդյունքի դեպքում զրոյացնում ենք dl-ը (false)
	ProcEnd3:
		pop cx ax di ; վերականգնում ենք փոփոխված ռեգիստորները
		ret
IsPfcRow endp

; տպում է ax-ում գտնվող թիվը կոնսոլում
PrNumber proc
		push bx cx ax dx ; պահում ենք փոփոխվող ռեգիստորները
		mov  bx, 10      ; պատրաստվում ենք բաժանել 10-ի
		xor  cx, cx      ; զրոյացնում ենք cx-ը (որպես թվանշանների հաշվիչ)
	CheckDig:
		xor  dx, dx   ; պատրաստվում ենք բաժանման
		div  bx       ; բաժանում ենք 10-ի
		push dx       ; մնացորդը պահում ենք stack-ում
		inc  cx       ; թվանշանների քանակը ավելացնում ենք 1-ով
		cmp  ax, 0    ; համեմատում ենք քանորդը 0-ի հետ
		je   PopDigs  ; եթե հավասար է վերջացնում ենք թվանշանների բաժանումը
		jmp  CheckDig ; հակառակ դեպքում կրկնում ենք
	PopDigs:
		pop  dx      ; stack-ից վերցնում ենք վերջին ավելացրած թվանշանը
		add  dx, 30h ; դարձնում ենք սիմվոլ
		mov  ah, 6   ; տպում ենք
		int  21h
		loop PopDigs ; թվանշանների քանակը 0 չլինելու դեպքում կրկնում ենք
	ProcEnd4:
		pop dx ax cx bx ; վերականգնում ենք փոփոխված ռեգիստորները
		ret
PrNumber endp
end      Main
