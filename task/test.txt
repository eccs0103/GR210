.model small
.stack 64
.data
Matrix	dw 1, 3, 6, 100, 200, 300, 6, 28, 496, 5, 25, 125
Columns	db 3
Rows	db 4
.code
Main proc far
			mov AX, @data
			mov DS, AX
			; սկիզբ
			xor DH, DH				; կատարյալ տողերի քանակը կպահենք DH-ում
			xor BX, BX				; հաշվարկը կսկսենք 0-ից
			mov AL, Columns			; AX-ում կպահենք սյուների քանակը արագ հասանելիության համար
			xor AH, AH
			mov CL, Rows			; CX-ում տողերի քանակով պետք է կրկնենք տվյալ գործողությունը
			xor CH, CH
MtrxLoop:	push CX					; պահում ենք CX-ի արժեքը, քանի որ նրանով ենք աշխատելու
			mov CX, AX				; ֆունկցիան պետք է անցնի սյուների քանակին հավասար քանակությամբ անդամների վրայով
			call IsPfcRow			; ստուգում ենք տողի կատարյալ լինելը
			cmp DL, 1
			jne NextIte2			; չլինելու դեպքում անցնում ենք NextIte2
			inc DH					; լինելու դեպքում ավելացնում ենք 1-ով նոր ենք անցնում
NextIte2:	pop CX					; վերականգնում ենք CX-ը
			add BX, AX				; BX-ը պետք է ավելացվի սյուների քանակ * բայթերի քանակով, որը տվյալ դեպքում 2 է
			add BX, AX				; հետևաբար ես ուղղակի 2 անգամ կավելացնեմ BX-ին սյուների քանակը
			loop MtrxLoop			; կրկնում ենք ցիկլը
			mov AL, DH
			xor AH, AH
			call PrNumber
			; ավարտ
			ret
Main endp

; Ստուգում է AX ռեգիստորը բաժանվում է BX-ի վրա անմնացորդ
; Արդյունքը վերադարձնում է 0 / 1 տեսքով DL-ում
IsDivis proc
			push AX					; պահում ենք փոփոխվող ռեգիստորները
			push DX					; պահում ենք DX-ը շուտով վերականգնելու համար
			xor DX, DX				; զրոյացնում ենք DX-ը բաժանելու համար
			div BX					; բաժանում ենք AX-ը BX-ի վրա ստանալով DX մնացորդ
			cmp DX, 0				; համեմատում ենք մնացորդը 0-ի հետ
			je True1				; եթե հավասար է անցնում է True1 նշիչին
			pop DX					; հակառակ դեպքում վերականգնում ենք DX-ը (DH-ը վերականգնելու համար)
			xor DL, DL				; DL-ը զրոյացնում ենք (այսինքն false արժեք)
			jmp ProcEnd1			; անցնում ենք ProcEnd1 նշիչին
True1:		pop DX					; ճիշտ արդյունքի դեպքում վերականգնում ենք DX-ը (DH-ը վերականգնելու համար)
			mov DL, 1				; DL-ին վերագրում ենք 1 (այսինքն true արժեք)
ProcEnd1:	pop AX					; վերականգնում ենք AX-ը
			ret
IsDivis endp

; ստուգում է AX ռեգիստորը կատարյալ է
; արդյունքը վերադարձնում է 0 / 1 տեսքով DL-ում
IsPerfec proc
			push SI BX CX DX		; պահում ենք փոփոխվող ռեգիստորները
			push AX					; պահում ենք AX-ը շուտով վերականգնելու համար
			xor SI, SI				; զրոյացնում ենք գումարը (բաժանարարների գումարը կպահենք SI-ում, ուրիշ ռեգիստոր չկա ¯\_(ツ)_/¯)
			mov BX, 2				; պատրաստվում ենք բաժանել 2-ի
			xor DX, DX				; ավելի ուժեղ ենք պատրաստվում բաժանել 2-ի
			div BX					; բաժանում ենք 2-ի
			mov CX, AX				; արդյունքը տեղափոխում ենք CX (որպես հաշվիչ և հերթական բաժանարար)
			pop AX					; վերականգնում ենք AX-ը
DivCheck:	cmp CX, 1				; եթե հերթական բաժանարարը փոքր է մեկից․․․
			jl LoopEnd1				; ավարտում ենք ցիկլը
			mov BX, CX				; հակառակ դեպքում տեղափոխում ենք BX բաժանման համար
			call IsDivis			; ստուգում ենք բաժանելիությունը
			cmp DL, 1
			jne NextIte1			; եթե չի բաժանվում անցնում ենք NextIte1 նշիչին
			add SI, BX				; բաժանվելու դեպքում գումարում ենք SI-ին
NextIte1:	dec CX					; անցնում ենք մեկով փոքր բաժանարարին
			jmp DivCheck			; կրկնում ենք ցիկլը
LoopEnd1:	pop DX					; վերականգնում ենք DX-ը (DH-ը վերականգնելու համար)
			xor DL, DL				; զրոյացնում ենք DL-ը (եթե false արդյունք ստացվի կթողնենք այդպես)
			cmp AX, SI				; համեմատում ենք նախնական թիվն ու գումարը
			jne ProcEnd2			; եթե հավասար չեն անցնում ենք վերջին (false) արդյունքով
			mov DL, 1				; եթե հավասար են անցնում ենք վերջին (true) արդյունքով
ProcEnd2:	pop CX BX SI			; վերականգնում ենք փոփոխված ռեգիստորները
			ret
IsPerfec endp

; ստուգում է Matrix-ում տարրերի կատարյալ լինելը BX հասցեից սկսած CX-ի չափով
; արդյունքը վերադարձնում է 0 / 1 տեսքով DL-ում
IsPfcRow proc
			push DI AX CX			; պահում ենք փոփոխվող ռեգիստորները
			xor DI, DI				; զրոյացնում ենք հասցեն
RowCheck:	mov AX, Matrix[BX][DI]	; AX-ում պահում ենք տողի հերթական տարրը
			call IsPerfec			; ստուգում ենք կատարյալ լինելը
			cmp DL, 1
			jne False2				; եթե կատարյալ չէ անցնում է False2 նշիչին
			add DI, 2				; հակառակ դեպքում հասցեն ավելացնում է 1-ով
			loop RowCheck			; և կրկնում ստուգումը հաջորդ տարրի համար
			mov DL, 1				; ցիկլը ավարտելուց և false չստանալու դեպքում վերագրում ենք DL-ին 1 (true)
			jmp ProcEnd3			; անցնում ենք վերջին
False2:		xor DL, DL				; սխալ արդյունքի դեպքում զրոյացնում ենք DL-ը (false)
ProcEnd3:	pop CX AX DI			; վերականգնում ենք փոփոխված ռեգիստորները
			ret
IsPfcRow endp

; տպում է AX-ում գտնվող թիվը կոնսոլում
PrNumber proc
			push BX CX AX DX		; պահում ենք փոփոխվող ռեգիստորները
			mov BX, 10				; պատրաստվում ենք բաժանել 10-ի
			xor CX, CX				; զրոյացնում ենք CX-ը (որպես թվանշանների հաշվիչ)
CheckDig:	xor DX, DX				; պատրաստվում ենք բաժանման
			div BX					; բաժանում ենք 10-ի
			push DX					; մնացորդը պահում ենք stack-ում
			inc CX					; թվանշանների քանակը ավելացնում ենք 1-ով
			cmp AX, 0				; համեմատում ենք քանորդը 0-ի հետ
			je PopDigs				; եթե հավասար է վերջացնում ենք թվանշանների բաժանումը
			jmp CheckDig			; հակառակ դեպքում կրկնում ենք
PopDigs:	pop DX					; stack-ից վերցնում ենք վերջին ավելացրած թվանշանը
			add DX, 30h				; դարձնում ենք սիմվոլ
			mov AH, 6				; տպում ենք
			int 21h
			loop PopDigs			; թվանշանների քանակը 0 չլինելու դեպքում կրկնում ենք
ProcEnd4:	pop DX AX CX BX			; վերականգնում ենք փոփոխված ռեգիստորները
			ret
PrNumber endp
end Main
